<?php
/**********************************************************************
    Copyright (C) AgroPhos, LLC.
	Released under the terms of the GNU General Public License,
	GPL, as published by the Free Software Foundation, either version 
	3 of the License, or (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
    See the License here <http://www.gnu.org/licenses/gpl-3.0.html>.
***********************************************************************/

/**
 * @return Returns the array sorted as required
 * @param $aryData Array containing data to sort
 * @param $strIndex name of column to use as an index
 * @param $strSortBy Column to sort the array by
 * @param $strSortType String containing either asc or desc [default to asc]
 * @desc Naturally sorts an array using by the column $strSortBy
 */
define('EXPORT_MAX_INSERT', 50000);

function array_natsort($aryData, $strIndex, $strSortBy, $strSortType=false)
{
   
   if (!is_array($aryData) || !$strSortBy)
       
       return $aryData;

   
   $arySort = $aryResult = array();

   
   foreach ($aryData as $key => $aryRow)
       
       $arySort[$strIndex ? $aryRow[$strIndex] : $key] = $aryRow[$strSortBy];

   
   natsort($arySort);

   
   if ($strSortType=="desc")
       
       arsort($arySort);

   
		foreach ($arySort as $arySortKey => $arySorted)
			if($strIndex) 
			{
				foreach ($aryData as $aryOriginal)
				
					if ($aryOriginal[$strIndex]==$arySortKey)
						
						array_push($aryResult, $aryOriginal);
			} else
				$aryResult[$arySortKey] = $aryData[$arySortKey];
   
   return $aryResult;
}

function update_admin_password($conn, $password)
{
	$sql = "UPDATE ".$conn['tbpref']."users SET password=".db_escape($password) . "
		WHERE user_id='admin'";
	db_query($sql, "could not update user password for 'admin'");
}

function write_config_db($new = false)
{
	global $path_to_root, $def_coy, $db_connections, $tb_pref_counter;

	if ($new)
		$tb_pref_counter++;
	$msg = "<?php\n\n";
	$msg .= "/*Connection Information for the database\n";
	$msg .= "\$def_coy - the default company that is pre-selected on login\n\n";
	$msg .= "'host' - the computer ip address or name where the database is. The default is 'localhost' assuming that the web server is also the sql server.\n\n";
	$msg .= "'port' - the computer port where the database is. The default is '3306'. Set empty for default.\n\n";
	$msg .= "'dbuser' - the user name under which the company database should be accessed.\n";
	$msg .= "  NB it is not secure to use root as the dbuser with no password - a user with appropriate privileges must be set up.\n\n";
	$msg .= "'dbpassword' - the password required for the dbuser to authorise the above database user.\n\n";
	$msg .= "'dbname' - the name of the database as defined in the RDMS being used. Typically RDMS allow many databases to be maintained under the same server.\n";
	$msg .= "'collation' - the character set used for the database.\n";
	$msg .= "'tbpref' - prefix on table names, or '' if not used. Always use non-empty prefixes if multiply company use the same database.\n";
	$msg .= "*/\n\n\n";

	$msg .= "\$def_coy = " . $def_coy . ";\n\n";
	$msg .= "\$tb_pref_counter = " . $tb_pref_counter . ";\n\n";
	$msg .= "\$db_connections = " .var_export($db_connections, true);
	$msg .= ";\n";

	$filename = $path_to_root . "/config_db.php";
	
	if ((!file_exists($filename) && is_writable($path_to_root)) || is_writable($filename))
	{
		if (!$zp = fopen($filename, 'w'))
		{
			return -1;
		}
		else
		{
			if (!fwrite($zp, $msg))
			{
				fclose($zp);
				return -2;
			}
			
			fclose($zp);
			cache_invalidate($filename);
		}
	}
	else
	{
		return -3;
	}
	return 0;
}

function write_extensions($extensions=null, $company = -1)
{
	global $path_to_root, $installed_extensions, $next_extension_id;

	if (!isset($extensions)) {
		$extensions = $installed_extensions;
	}
	if (!isset($next_extension_id)) {
		$next_extension_id = 1;
	}

	$msg = "<?php\n\n";
	if ($company == -1)
		$msg .=
"/* List of installed additional extensions. If extensions are added to the list manually
	make sure they have unique and so far never used extension_ids as a keys,
	and \$next_extension_id is also updated. More about format of this file yo will find in 
	FA extension system documentation.
*/
\n\$next_extension_id = $next_extension_id; 
	else 
		$msg .=
"/*
	Do not edit this file manually. This copy of global file is overwritten
	by extensions editor.
*/\n\n";

	$msg .= "\$installed_extensions = ". var_export($extensions, true);
	$msg .= ";\n";
	$filename = $path_to_root . ($company==-1 ? '' : '/company/'.$company)
		.'/installed_extensions.php';

	
	if (!$zp = @fopen($filename, 'w'))
	{
		display_error(sprintf(_("Cannot open the extension setup file '%s' for writing."),
			 $filename));
		return false;
	}
	else
	{
		if (!fwrite($zp, $msg))
		{
			display_error(sprintf(_("Cannot write to the extensions setup file '%s'."),
				$filename));
			fclose($zp);
			return false;
		}
		
		fclose($zp);
		cache_invalidate($filename);
	}
	return true;
}
//---------------------------------------------------------------------------------------------
//

//
function update_extensions($extensions) {
	global $db_connections;
	
	if (!write_extensions($extensions)) {
		display_notification(_("Cannot update system extensions list."));
		return false;
	}

	
 	$cnt = max(1, count_array($db_connections));
	for($i = 0; $i < $cnt; $i++) 
	{
		$newexts = $extensions;
		
		$exts = get_company_extensions($i);
		foreach ($exts as $key => $ext) 
		{
			if (isset($newexts[$key]))
				$newexts[$key]['active'] = $exts[$key]['active'];
		}
		if(!write_extensions($newexts, $i)) 
		{
			display_notification(sprintf(_("Cannot update extensions list for company '%s'."),
				$db_connections[$i]['name']));
		 return false;
		}
	}
	return true;
}


function write_lang()
{
	global $path_to_root, $installed_languages, $dflt_lang;

	$installed_languages = array_natsort($installed_languages, 'code', 'code');
	$msg = "<?php\n\n";

	$msg .= "/* How to make new entries here for non-packaged languages:\n\n";
	$msg .= "-- 'code' should match the name of the directory for the language under \\lang\n.";
	$msg .= "-- 'name' is the name that will be displayed in the language selection list (in Users and Display Setup)\n";
	$msg .= "-- 'rtl' only needs to be set for right-to-left languages like Arabic and Hebrew\n";
	$msg .= "-- 'encoding' used in translation file\n";
	$msg .= "-- 'version' always set to '' for manually installed languages.\n";
	$msg .= "-- 'path' installation path related to FA root (e.g. 'lang/en_US').\n";
	$msg .= "*/\n\n\n";

	$msg .= "\$installed_languages = " . var_export($installed_languages, true);
	$msg .= ";\n";
	$msg .= "\n\$dflt_lang = '$dflt_lang';\n";

	$path = $path_to_root . "/lang";
	$filename = $path.'/installed_languages.inc';
	
	if (file_exists($path) && is_writable($path))
	{
		if (!$zp = fopen($filename, 'w'))
		{
			display_error(_("Cannot open the languages file - ") . $filename);
			return false;
		}
		else
		{
			if (!fwrite($zp, $msg))
			{
				display_error(_("Cannot write to the language file - ") . $filename);
				fclose($zp);
				return false;
			}
			
			fclose($zp);
			cache_invalidate($filename);
		}
	}
	else
	{
		display_error(_("The language files folder ") . $path . _(" is not writable. Change its permissions so it is, then re-run the operation."));
		return false;
	}
	return true;
}
/*
	Database import:
		$filename - sql file name
		$connection - database connection
		$force - ignore duplicate errors
		$init - presume $filename is initialization file with '0_' prefix
		$protect - protect users/roles 
		$return_errors - return errors instead of display them
*/
function db_import($filename, $connection, $force=true, $init=true, $protect=false, $return_errors=false)
{
	global $db, $SysPrefs;

	$trail = $SysPrefs->sql_trail;
	$SysPrefs->sql_trail = false;

	$allowed_commands = array(
		"create"  => 'table_queries', 
		"delimiter" => 'table_queries',
		"alter table" => 'table_queries', 
		"insert" => 'data_queries', 
		"update" => 'data_queries', 
		"set names" => 'set_names',
		"drop table if exists" => 'drop_queries',
		"drop function if exists" => 'drop_queries',
		"drop trigger if exists" => 'drop_queries',
		"select" => 'data_queries', 
		"delete" => 'data_queries',
		"drop view if exists" => 'drop_queries',
		"create view as" => 'data_queries'		//we should be able to create views after all tables have been created 
		);

	$protected = array(
		'security_roles',
		'users'
	);

	$ignored_mysql_errors = array( //errors ignored in normal (non forced) mode
		'1022',	
		'1050', 
		'1060', 
		'1061', 
		'1062', 
		'1091'  
	);

	$set_names = array();
	$data_queries = array();
	$drop_queries = array();
	$table_queries = array();
	$sql_errors = array();

	$old_encoding = db_get_charset($db);

	ini_set("max_execution_time", max("180", ini_get("max_execution_time")));
	db_query("SET foreign_key_checks=0");
	db_query("SET sql_mode=''");

	if (isset($connection['collation']))
		db_set_collation($db, $connection['collation']);

	$check_line_len = false;

	
	if (strpos($filename, ".gz") || strpos($filename, ".GZ"))
	{	$lines = db_ungzip("lines", $filename);
		$check_line_len = true;
	} elseif (strpos($filename, ".zip") || strpos($filename, ".ZIP"))
		$lines = db_unzip("lines", $filename);
	else
		$lines = file("". $filename);

	
	$query_table = '';
	$delimiter = ';';

	foreach($lines as $line_no => $line)
	{
		$gzfile_bug = $check_line_len && (strlen($line) == 8190); 

		$line = trim($line);
		if ($init)
			$line = str_replace("0_", $connection["tbpref"], $line);

		if ($query_table == '') 
		{	
		 	foreach($allowed_commands as $cmd => $table) 
			{
				if (strtolower(substr($line, 0, strlen($cmd))) == $cmd) 
				{
					if ($cmd == 'delimiter') {
						$delimiter = trim(substr($line, 10));
						continue 2;
					}
					$query_table = $table;
					$skip = false;
					if ($protect)
					{
						foreach($protected as $protbl)
							if (strpos($line, $connection["tbpref"].$protbl) !== false)
							{
								$skip = true; break;
							}
					}
					if (!$skip)
						${$query_table}[] = array('', $line_no+1);
					break;
				}
		 	}
		 }
		 if($query_table != '')  
		 {
		 	$table = $query_table;
			if (!$gzfile_bug && substr($line, -strlen($delimiter)) == $delimiter) 
			{
				$line = substr($line, 0, strlen($line) - strlen($delimiter)); 
				$query_table = '';
			}
			if (!$skip)
				${$table}[count(${$table}) - 1][0] .= $line . "\n";
		}

	}

	//
	
	
	//
	$encoding = null; 
	$new_db = $init || db_fixed();
	$new_file = count($set_names);
	if ($new_db)
	{
		if ($new_file)
		{
			if (count($set_names)) 
			{
				if (preg_match('/set\s*names\s*[\']?(\w*)[\']?/i', $set_names[0][0], $match))
					$encoding = $match[1];
			}
			
		}
	}
	else
	{
		if ($new_file) 
		{
			$msg = _("This is new format backup file which cannot be restored on database not migrated to utf8.");
			if ($return_errors)
				return $msg;
			else
				display_error($msg);
			return false;
		}
		 else	
			$encoding = 'latin1'; 
	}

	db_set_charset($db, $encoding);

/*/	{ 	
	global $path_to_root;
	$f = fopen($path_to_root.'/tmp/dbimport.txt', 'w+');
	fwrite($f, print_r($set_names,true) ."\n");
	fwrite($f, print_r($drop_queries,true) ."\n");
	fwrite($f, print_r($table_queries,true) ."\n");
	fwrite($f, print_r($data_queries,true));
	fclose($f);
	}
/*/
	if ($return_errors)
	{	
		$save_debug = $SysPrefs->go_debug;
		$SysPrefs->go_debug = 0;
	}
	
	if (is_array($drop_queries))
	{
		foreach($drop_queries as $drop_query)
		{
			if (!db_query($drop_query[0]))
			{
				if (!in_array(db_error_no(), $ignored_mysql_errors) || !$force)
					$sql_errors[] = array(db_error_msg($db), $drop_query[1]);
			}
		}
	}

	
	if (is_array($table_queries))
	{
		foreach($table_queries as $table_query)
		{
			if (!db_query($table_query[0]))
			{	
				if (!in_array(db_error_no(), $ignored_mysql_errors) || !$force) {
					$sql_errors[] = array(db_error_msg($db), $table_query[1]);
				}
			}
		}
	}

	
	if (is_array($data_queries))
	{
		foreach($data_queries as $data_query)
		{
			if (!db_query($data_query[0]))
			{
				if (!in_array(db_error_no(),$ignored_mysql_errors) || !$force)
					$sql_errors[] = array(db_error_msg($db), $data_query[1]);
			}
		}
	}

	if ($return_errors)
		$SysPrefs->go_debug = $save_debug;

	$SysPrefs->sql_trail = $trail;

	db_query("SET foreign_key_checks=1");
	if ($delimiter != ';') db_query("delimiter ;"); 

	db_set_charset($db, $old_encoding); 

	if (count($sql_errors)) {
		if ($return_errors)
			return $sql_errors;

		
		$err = $sql_errors[0];
		display_error(sprintf(_("SQL script execution failed in line %d: %s"),
			$err[1], $err[0]));
		return false;
	} else
		return true;
}


function db_ungzip($mode, $path)
{
    $file_data = gzfile($path);
    
    if ($mode != "lines")
    	return implode("",$file_data);
    else
    	return $file_data;
}


function db_unzip($mode, $path)
{
    $all = false;
    $all = implode("", file($path));

    
    $filename = preg_replace("/.*\//", "", $path);
    $filename = substr($filename, 0, strlen($filename) - 4);

    
    if (substr($all, 30, strlen($filename)-4) . substr($all, 30+strlen($filename)+9, 4)
	  != $filename) {
		return '';     
    }
    else
    {
    	
		$crc_bugfix = substr($all, 30, strlen($filename)+13);
        $crc_bugfix = substr(substr($crc_bugfix, 0, strlen($crc_bugfix) - 4), 
				strlen($crc_bugfix) - 12 - 4);
        $suffix = false;
        
        for ($i=0; $i < 12; )
        	$suffix .= chr($crc_bugfix[$i++] . $crc_bugfix[$i++] . $crc_bugfix[$i++]);

        
        $comp = substr($all, -(strlen($all) - 30 - strlen($filename)-13));
        $comp = substr($comp, 0, (strlen($comp) - 80 - strlen($filename)-13));

        
        $comp = "x�" . $comp . $suffix;
        $file_data = gzuncompress($comp);
    }

    
    if ($mode != "lines")
    	return $file_data;
    else
    	return explode("\n", $file_data);
}

function db_backup($conn, $ext='no', $comm='', $path='')
{
	if ($conn['tbpref'] != "")
		$filename = $conn['dbname'] . "_" . $conn['tbpref'] . date("Ymd_Hi") . ".sql";
	else
		$filename = $conn['dbname'] . "_" . date("Ymd_Hi") . ".sql";

	return db_export($conn, $path . clean_file_name($filename), $ext, $comm);
}

//
function db_export($conn, $filename, $zip='no', $comment='')
{

	global $SysPrefs, $version;

    $error = false;
    
    $max_size = 1048576 * 2; 
    
    if (ini_get("memory_limit"))
    	$max_size = 1048576 * (int)ini_get("memory_limit");
    
    if ($zip == "gzip")
    	$backupfile = $filename . ".gz";
    elseif ($zip == "zip")
    	$backupfile = $filename . ".zip";
    else
    	$backupfile = $filename;
    $company = $conn['name']; 

	if (file_exists($backupfile))	
		unlink($backupfile);

    //create comment
    $out="# MySQL dump of database '".$conn["dbname"]."' on host '".$conn["host"]."'\n";
    $out.="# Backup Date and Time: ".date("Y-m-d H:i")."\n";
    $out.="# Built by " . $SysPrefs->app_title . " " . $version ."\n";
    $out.="# ".$SysPrefs->power_url."\n";
    $out.="# Company: ". @html_entity_decode($company, ENT_QUOTES, $_SESSION['language']->encoding)."\n";
    $out.="# User: ".$_SESSION["wa_current_user"]->name."\n\n";
    $out.="# Compatibility: ".get_company_pref('version_id')."\n\n";

	
	if ($comment)
	{
		$out .= "# Comment:\n";
		$comment=preg_replace("'\n'","\n# ","# ".$comment);
		//$comment=str_replace("\n", "\n# ", $comment);
		foreach(explode("\n",$comment) as $line)
			$out .= $line."\n";
		$out.="\n";
	}

	if (db_fixed())
	{
		db_set_encoding();
		if ($mysql_enc = get_mysql_encoding_name($_SESSION['language']->encoding))
			$out .= "\nSET NAMES $mysql_enc;\n";
	}
    
    $res = db_query("show table status");
    $all_tables = array();
    while($row = db_fetch($res))
    {
		if (($conn["tbpref"] == "" && !preg_match('/[0-9]+_/', $row['Name'])) ||
			($conn["tbpref"] != "" && strpos($row['Name'], $conn["tbpref"]) === 0))
    		$all_tables[] = $row;
    }
        
	foreach ($all_tables as $table)
	{
		$res1 = db_query("SHOW CREATE TABLE `" . $table['Name'] . "`");
		$tmp = db_fetch($res1);
		$table_sql[$table['Name']] = $tmp["Create Table"];
	}

	
	$fks = array();
	if (isset($table_sql))
	{
		foreach($table_sql as $tablenme=>$table)
		{
			$tmp_table=$table;
			
			while (($ref_pos = strpos($tmp_table, " REFERENCES ")) > 0)
			{
				$tmp_table = substr($tmp_table, $ref_pos + 12);
				$ref_pos = strpos($tmp_table, "(");
				$fks[$tablenme][] = substr($tmp_table, 0, $ref_pos);
			}
		}
	}
	
	$all_tables = order_sql_tables($all_tables, $fks);

	
	if (!$error)
	{
		foreach ($all_tables as $row)
		{
			if (!empty($row['Engine'])) {	//don't export views like tables
				$tablename = $row['Name'];
				$auto_incr[$tablename] = $row['Auto_increment'];
	
				$out.="\n\n";
				
				$out.="### Structure of table `".$tablename."` ###\n\n";
	
				$out.="DROP TABLE IF EXISTS `".$tablename."`;\n\n";
				$out.=$table_sql[$tablename];
	
				$out.=" ;";
				$out.="\n\n";
	
				
				if (!$error)
				{
					$out.="### Data of table `".$tablename."` ###\n";
	
					
					$res3 = db_query("SHOW COLUMNS FROM `" . $tablename . "`");
	
					$field_null = array();
					for ($j = 0; $j < db_num_rows($res3); $j++)
					{
						$row3 = db_fetch($res3);
						$field_null[] = $row3[2]=='YES' && $row3[4]===null;
					}
	
					$res2 = db_query("SELECT * FROM `" . $tablename . "`");
					$maxinsert = 0;
					$insert = '';
					for ($j = 0; $j < db_num_rows($res2); $j++)
					{
						$row2 = db_fetch_row($res2);
						$values = '(';
						for ($k = 0; $k < $nf = db_num_fields($res2); $k++)
						{
							$values .= db_escape($row2[$k], $field_null[$k]);
							if ($k < ($nf - 1))
								$values .= ', ';
						}
						$values .= ')';
						$len = strlen($values);
						if ($maxinsert < $len+1)
						{
							$maxinsert = EXPORT_MAX_INSERT;
							if ($insert)
							{
								$out .= $insert .';'; 
								$insert = '';
							}
						}
	
						if ($insert == '')
						{
							$insert = "\nINSERT INTO `" . $tablename . "` VALUES\n";
							$maxinsert -= strlen($insert);
						} else {
							$insert .= ",\n";
						}
	
						$maxinsert -= $len;
						$insert .= $values;
	
						
						if (strlen($out) > $max_size && $zip != "zip")
						{
							if (save_to_file($backupfile, $zip, $out))
								$out = "";
							else
								$error = true;
						}
					}
					if ($insert)
						$out .= $insert. ';';
				
				}
				elseif ($error)
				{
					@unlink($backupfile);
					return false;
				}
	
				
				if (strlen($out) > $max_size && $zip != "zip")
				{
					if (save_to_file($backupfile, $zip, $out))
						$out= "";
					else
						$error = true;
				}
			}	//end if Engine set (not a view)
		}
		//process views last so all tables have been created before views are created
		foreach ($all_tables as $row)
		{
			if (empty($row['Engine'])) {
				$viewname = $row['Name'];
				$out .= "\n\nDROP VIEW IF EXISTS `".$viewname."`;\n";
				//db_get_view_schema() is in /includes/db/connect_db_mysqli.inc because it is mysql specific
				if (NULL !== ($schema = db_get_view_schema($viewname)))
				{
					$out .= "CREATE VIEW `".$viewname."` AS ".$schema.";\n\n";
					if (!save_to_file($backupfile, $zip, $out)) $error = true;
					else $out = "";
				}
				else $error = true;
				
				if ($error) {
					@unlink($backupfile);
					return false;
				}
			}
		}

	
	}
	else
	{
		@unlink($backupfile);
		return false;
	}

	if (save_to_file($backupfile, $zip, $out))
	{
		$out = "";
	}
	else
	{
		@unlink($backupfile);
		return false;
	}
    return $backupfile;
}



function order_sql_tables($tables, $fks)
{
	
	if (!count($fks))
		return $tables;

	
	$new_tables = array();
	$existing = array();
	$modified = true;
	while (count($tables) && $modified == true)
	{
	 	$modified = false;
	    foreach ($tables as $key=>$row)
	    {
	        
	        if (isset($fks[$row['Name']]))
	        {
	        	foreach($fks[$row['Name']] as $needed)
	        	{
	            	
	                if (!in_array($needed,$existing))
	                	continue 2;
	            }
	        }
            
	        $existing[] = $row['Name'];
			$new_tables[] = $row;
            prev($tables);
            unset($tables[$key]);
            $modified = true;

	    }
	}

	if (count($tables))
	{
	    
	    
	    
	    foreach($tables as $row)
	    	$new_tables[] = $row;
	    echo "<div class=\"red_left\">THIS DATABASE SEEMS TO CONTAIN 'RING CONSTRAINTS'. WA DOES NOT SUPPORT THEM. PROBABLY THE FOLOWING BACKUP IS DEFECT!</div>";
	}
	return $new_tables;
}



function save_to_file($path, $zip, $fileData)
{

	$backupfile = basename($path);

    if ($zip == "gzip")
    {
        if ($zp = @gzopen($path, "a9"))
        {
			@gzwrite($zp, $fileData);
			@gzclose($zp);
			return true;
        }
        else
        {
        	return false;
        }

    
    }
    elseif ($zip == "zip")
    {
        
        

        
        $eof_ctrl_dir = "\x50\x4b\x05\x06\x00\x00\x00\x00";

        
        $unc_len = strlen($fileData);
        $crc = crc32($fileData);
        $zdata = gzcompress($fileData);

		
        
        $name_suffix = substr($zdata, -4, 4);
        $name_suffix2 = "_";
        for ($i = 0; $i < 4; $i++)
        	$name_suffix2 .= sprintf("%03d", ord($name_suffix[$i]));

      	$name = substr($backupfile, 0, strlen($backupfile) - 8) . $name_suffix2 . ".sql";

        
        $zdata = substr(substr($zdata, 0, strlen($zdata) - 4), 2);
        $c_len = strlen($zdata);

        
        $timearray = getdate();
        $dostime = (($timearray['year'] - 1980) << 25) | ($timearray['mon'] << 21) | ($timearray['mday'] << 16) |
            ($timearray['hours'] << 11) | ($timearray['minutes'] << 5) | ($timearray['seconds'] >> 1);
        $dtime = dechex($dostime);
        $hexdtime = "\x" . $dtime[6] . $dtime[7] . "\x" . $dtime[4].$dtime[5] . "\x" . $dtime[2] . $dtime[3] . "\x" . $dtime[0] . $dtime[1];
        eval('$hexdtime="' . $hexdtime . '";');

        
        $sub1 = "\x14\x00" . "\x00\x00" . "\x08\x00" . $hexdtime;

        
        $sub2 = pack('V', $crc) . pack('V', $c_len) . pack('V', $unc_len);

        $fr = "\x50\x4b\x03\x04" . $sub1. $sub2;

        
        $fr .= pack('v', strlen($name)) . pack('v', 0);
        $fr .= $name;

        
        $fr .= $zdata . $sub2;

        
        $cdrec = "\x50\x4b\x01\x02";
        $cdrec .= "\x00\x00";                
        $cdrec .= $sub1 . $sub2;

         
        $cdrec .= pack('v', strlen($name)) . pack('v', 0) . pack('v', 0) . pack('v', 0) . pack('v', 0) . pack('V', 32) . pack('V',0);
        $cdrec .= $name;

        
        $fileData = $fr . $cdrec . $eof_ctrl_dir;

        
        $fileData .= pack('v', 1) . pack('v', 1) . pack('V', strlen($cdrec)) . pack('V', strlen($fr)) . "\x00\x00";

        if ($zp = @fopen($path, "w"))
        {
			@fwrite($zp, $fileData);
			@fclose($zp);
			return true;
        }
        else
        {
        	return false;
        }

	
    }
    else
    {
        if ($zp = @fopen($path, "a"))
        {
			@fwrite($zp, $fileData);
			@fclose($zp);
			return true;
        }
        else
        {
        	return false;
        }
    }
}

function create_comp_dirs($comp_path, $comp_subdirs)
{
		$index = "<?php\nheader(\"Location: ../index.php\");\n";
	    $cdir = $comp_path;
	    @mkdir($cdir);
		$f = @fopen("$cdir/index.php", "wb");
		@fwrite($f, $index);
		@fclose($f);

	    foreach($comp_subdirs as $dir)
	    {
			@mkdir($cdir.'/'.$dir);
			$f = @fopen("$cdir/$dir/index.php", "wb");
			@fwrite($f, $index);
			@fclose($f);
	    }
}

//
//	Checks $field existence in $table with given field $properties
//	$table - table name without prefix


//		'Type', 'Null', 'Key', 'Default', 'Extra'
//
function check_table($pref, $table, $field=null, $properties=null)
{
	$tables = @db_query("SHOW TABLES LIKE '".$pref.$table."'");
	if (!db_num_rows($tables))
		return 1;		

	$fields = @db_query("SHOW COLUMNS FROM ".$pref.$table);
	if (!isset($field)) 
		return 0;		

	while( $row = db_fetch_assoc($fields)) 
	{
		if ($row['Field'] == $field) 
		{
			if (!isset($properties)) 
				return 0;
			foreach($properties as $property => $value) 
			{
				if ($row[$property] != $value) 
					return 3;	
			}
			return 0; 
		}
	}
	return 2; 
}

/*
	Update or create setting in simple php config file.
*/
function update_config_var($file, $variable, $value, $comment='')
{
	if (!is_file($file) || !is_writeable($file))
		return false;
	$content = file_get_contents($file);
	$strvalue = '$'."$variable = ".var_export($value, true).';';
	$pattern = '/'.preg_quote('$'.$variable).'\s*=\s*[^;]*;/m';
	$content = preg_replace($pattern, $strvalue, $content, -1, $result);
	if (!$result)
	{
		$strvalue = ($comment ? "
		$content = preg_replace('/\?>\s*/m', $strvalue, $content, -1, $result);
		if (!$result)
			$content .= $strvalue;
	}

	return file_put_contents($file, $content)!=false;
}


